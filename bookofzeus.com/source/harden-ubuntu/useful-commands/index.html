
<h2>System Information</h2>
<p>List the users logged in on the machine.</p>
<pre>
who
</pre>

<p>List all users logged in on your network. The rwho service must be enabled for this command to work.</p>
<pre>
rwho -a
</pre>

<p>System info about a user. Try: finger root last. This lists the users last logged-in on your system.</p>
<pre>
finger user_name
</pre>

<p>Show the last (1000 or so) commands executed from the command line on the current account. The | more causes the display to stop after each screen fill.</p>
<pre>
history | more
</pre>

<p>Print working directory, i.e. display the name of your current directory on the screen.</p>
<pre>
pwd
</pre>

<p>Print the name of the local host (the machine on which you are working).</p>
<pre>
hostname
</pre>

<p>Print your login name.</p>
<pre>
whoami
</pre>

<p>Print user id (uid) and his/her group id (gid), effective id (if different than the real id) and the supplementary groups.</p>
<pre>
id username
</pre>

<p>Print or change the operating system date and time. E.g., change the date and time to 2000-12-31 23:57 using this command</p>
<pre>
date
</pre>

<p>To set the hardware clock from the system clock, use the command (as root) setclock</p>
<pre>
date 123123572000
</pre>

<p>Determine the amount of time that it takes for a process to complete+ other info. Don't confuse it with date command. For e.g. we can find out how long it takes to display a directory content using time ls</p>
<pre>
time
</pre>

<p>Amount of time since the last reboot</p>
<pre>
uptime
</pre>

<p>List the processes that are have been run by the current user.</p>
<pre>
ps
</pre>

<p>List all the processes currently running, even those without the controlling terminal, together with the name of the user that owns each process.</p>
<pre>
ps aux | more
</pre>

<p>Keep listing the currently running processes, sorted by cpu usage (top users first).</p>
<pre>
top
</pre>

<p>Info on your server.</p>
<pre>
uname -a
</pre>

<p>Memory info (in kilobytes).</p>
<pre>
free
</pre>

<p>Print disk info about all the file systems in a human-readable form.</p>
<pre>
df -h
</pre>

<p>Print detailed disk usage for each subdirectory starting at root (in a human readable form).</p>
<pre>
du / -bh | more
</pre>

<p>(as root. Use /sbin/lsmod to execute this command when you are a non-root user.) Show the kernel modules currently loaded.</p>
<pre>
lsmod
</pre>

<p>Show the current user environment.</p>
<pre>
set|more
</pre>

<p>Show the content of the environment variable PATH. This command can be used to show other environment variables as well. Use set to see the full environment.</p>
<pre>
echo $PATH
</pre>

<p>Print kernel messages (the current content of the so-called kernel ring buffer). Press q to quit less. Use less /var/log/dmesg to see what dmesg dumped into the file right after bootup. - only works on dedciated systems</p>
<pre>
dmesg | less
</pre>

<h2>Commands for Process control</h2>

<p>PID Bring a background or stopped process to the foreground.</p>
<pre>
fg
</pre>

<p>PID Send the process to the background. This is the opposite of fg. The same can be accomplished with Ctrl z</p>
<pre>
bg
</pre>

<p>Run any command in the background (the symbol <q>&amp;</q> means run the command in the background?</p>
<pre>
any_command &amp;
</pre>

<p>Force a process shutdown. First determine the PID of the process to kill using ps.</p>
<pre>
kill PID
</pre>

<p>Kill program(s) by name.</p>
<pre>
killall -9 program_name
</pre>

<p>Run program_name adjusting its priority. Since the priority is not specified in this example, it will be adjusted by 10 (the process will run slower), from the default value (usually 0). The lower the number (of niceness to other users on the system), the higher the priority. The priority value may be in the range -20 to 19. Only root may specify negative values. Use top to display the priorities of the running processes.</p>
<pre>
nice program_name
</pre>

<p>(as root) Change the priority of a running process to -1. Normal users can only adjust processes they own, and only up from the current value (make them run slower).</p>
<pre>
renice -1 PID
</pre>

<h2>Mitigating (D)DOS</h2>
<p>If you're being DDOS'd or DOS'd you can use this command:</p>
<pre>
netstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -n
</pre>
<p>That will help you see how many connections each IP address has in total to your server.</p>

<h2>Other tools</h2>
<h3>dsniff</h3>
<p>This suite of packet-sniffing tools allows you to monitor traffic on your network for sensitive data. It comes with a number of tools, including its namesake, dsniff, which allows you to sniff network traffic that could potentially contain items such as passwords. It comes with the additional tools filesnarf, mailsnarf, and urlsnarf that specialize in sniffing for filenames, mail passwords, and traffic and HTTP traffic. dsniff requires libnet (http://www.packetfactory.net/projects/libnet/) and libnids (http://www.packetfactory.net/projects/libnids/) for operation. You can find dsniff at http://monkey.org/~dugsong/dsniff/.</p>

<h3>Ethereal</h3>
<p>Ethereal is a network data-capture tool that can grab data off your network and read in the contents of tcpdump files or read in data from a variety of other sources. You can dissect and analyze a variety of data from a wide selection of protocols and can even edit the contents of captured traffic. Ethereal also comes with an X-based GUI tool that you can use to display data being captured in real time. You can find Ethereal at http://www.ethereal.com/.</p>

<h3>Ettercap</h3>
<p>The Ettercap suite simulates and sniffs for man-in-the-middle attacks on your network. It is capable of sniffing live connections and performing content filtering on the fly. It can support active and passive dissection of a number of protocols and has built-in fingerprinting capabilities with a large library of fingerprints. You can find Ettercap at http://ettercap.sourceforge.net/.</p>

<h3>LIDS</h3>
<p>LIDS is a secured kernel designed to replace your existing kernel. It provides file-system protection, provides protection of processes (including hiding processes), introduces access control lists (ACLs) that allow you control access to applications, and contains some network security features and a port scanner detector. LIDS also has a built-in secured alerting system. You can find LIDS at http://www.lids.org/.

<h3>Netcat</h3>
<p>Netcat is similar in function to nmap but has some useful additional functionality. It is capable of the same network and port scanning as nmap but also allows you to send TCP/IP data. You can use it to open TCP connections, listen on arbitrary TCP and UDP ports, and send TCP and UDP packets. You can find Netcat at http://netcat.sourceforge.net/.</p>

<h3>Snort</h3>
<p>Snort is a packet-sniffing tool and intrusion-detection tool. It is a complex, powerful, and highly configurable tool. It can run in three modes: as a network sniffer reading packets off the network and displaying them, in packet logging mode logging those packets to disk, and in the last mode as a network intrusion detection tool. This allows you to match the packets against a series of rules. Some rules are provided by default, and you can also define your own; for example, as a new virus or worm is discovered, you can define a rule to detect that worm and identify any computers that may be infected. Snort can also perform actions, trigger events, or conduct alerting if it detects packets matching its or your rules. </p>
<p>You can find Snort at http://www.snort.org/.</p>

<h3>tcpdump</h3>
<p>One of the more useful tools in your security arsenal, the tcpdump command allows you to dump network traffic in the form of the headers of packets. You can select headers using Boolean expressions, collect packets from a particular interface, and use a variety of other options. You can display the packet headers on the console or log them to a file for later review. Most Linux systems come with the tcpdump command, or you can find it at http://www.tcpdump.org/.</p>

